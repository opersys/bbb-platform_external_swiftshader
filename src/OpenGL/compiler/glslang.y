/*
//
// Copyright (c) 2002-2015 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//

This file contains the Yacc grammar for GLSL ES.
Based on ANSI C Yacc grammar:
http://www.lysator.liu.se/c/ANSI-C-grammar-y.html

IF YOU MODIFY THIS FILE YOU ALSO NEED TO RUN generate_parser.sh,
WHICH GENERATES THE GLSL ES PARSER (glslang_tab.cpp AND glslang_tab.h).
*/

%{
//
// Copyright (c) 2002-2015 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//

// This file is auto-generated by generate_parser.sh. DO NOT EDIT!

// Ignore errors in auto-generated code.
#if defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wswitch-enum"
#elif defined(_MSC_VER)
#pragma warning(disable: 4065)
#pragma warning(disable: 4189)
#pragma warning(disable: 4505)
#pragma warning(disable: 4701)
#endif

#include "SymbolTable.h"
#include "ParseHelper.h"

#define YYENABLE_NLS 0

#define YYLEX_PARAM context->scanner
%}

%expect 1 /* One shift reduce conflict because of if | else */
%pure-parser
%parse-param {TParseContext* context}

%code requires {
#define YYLTYPE TSourceLoc
#define YYLTYPE_IS_DECLARED 1
}

%union {
    struct {
        TSourceLoc line;
        union {
            TString *string;
            float f;
            int i;
            unsigned int u;
            bool b;
        };
        TSymbol* symbol;
    } lex;
    struct {
        TSourceLoc line;
        TOperator op;
        union {
            TIntermNode* intermNode;
            TIntermNodePair nodePair;
            TIntermTyped* intermTypedNode;
            TIntermAggregate* intermAggregate;
            TIntermSwitch* intermSwitch;
            TIntermCase* intermCase;
        };
        union {
            TPublicType type;
            TPrecision precision;
            TLayoutQualifier layoutQualifier;
            TQualifier qualifier;
            TFunction* function;
            TParameter param;
            TField* field;
            TFieldList* fieldList;
        };
    } interm;
}

%{
extern int yylex(YYSTYPE* yylval, YYLTYPE* yylloc, void* yyscanner);
extern void yyerror(YYLTYPE* lloc, TParseContext* context, const char* reason);

#define YYLLOC_DEFAULT(Current, Rhs, N) do { (Current) = YYRHSLOC(Rhs, N ? 1 : 0); } while (0)

#define FRAG_VERT_ONLY(S, L) {  \
    if (context->shaderType != GL_FRAGMENT_SHADER &&  \
        context->shaderType != GL_VERTEX_SHADER) {  \
        context->error(L, " supported in vertex/fragment shaders only ", S);  \
        context->recover();  \
    }  \
}

#define VERTEX_ONLY(S, L) {  \
    if (context->shaderType != GL_VERTEX_SHADER) {  \
        context->error(L, " supported in vertex shaders only ", S);  \
        context->recover();  \
    }  \
}

#define FRAG_ONLY(S, L) {  \
    if (context->shaderType != GL_FRAGMENT_SHADER) {  \
        context->error(L, " supported in fragment shaders only ", S);  \
        context->recover();  \
    }  \
}

#define ES2_ONLY(S, L) {  \
    if (context->shaderVersion != 100) {  \
        context->error(L, " supported in GLSL ES 1.00 only ", S);  \
        context->recover();  \
    }  \
}

#define ES3_ONLY(S, L) {  \
    if (context->shaderVersion != 300) {  \
        context->error(L, " supported in GLSL ES 3.00 only ", S);  \
        context->recover();  \
    }  \
}
%}

%token <lex> INVARIANT HIGH_PRECISION MEDIUM_PRECISION LOW_PRECISION PRECISION
%token <lex> ATTRIBUTE CONST_QUAL BOOL_TYPE FLOAT_TYPE INT_TYPE UINT_TYPE
%token <lex> BREAK CONTINUE DO ELSE FOR IF DISCARD RETURN SWITCH CASE DEFAULT
%token <lex> BVEC2 BVEC3 BVEC4 IVEC2 IVEC3 IVEC4 VEC2 VEC3 VEC4 UVEC2 UVEC3 UVEC4
%token <lex> MATRIX2 MATRIX3 MATRIX4 IN_QUAL OUT_QUAL INOUT_QUAL UNIFORM VARYING
%token <lex> MATRIX2x3 MATRIX3x2 MATRIX2x4 MATRIX4x2 MATRIX3x4 MATRIX4x3
%token <lex> CENTROID FLAT SMOOTH
%token <lex> STRUCT VOID_TYPE WHILE
%token <lex> SAMPLER2D SAMPLERCUBE SAMPLER_EXTERNAL_OES SAMPLER2DRECT SAMPLER2DARRAY
%token <lex> ISAMPLER2D ISAMPLER3D ISAMPLERCUBE ISAMPLER2DARRAY
%token <lex> USAMPLER2D USAMPLER3D USAMPLERCUBE USAMPLER2DARRAY
%token <lex> SAMPLER3D SAMPLER3DRECT SAMPLER2DSHADOW SAMPLERCUBESHADOW SAMPLER2DARRAYSHADOW
%token <lex> LAYOUT

%token <lex> IDENTIFIER TYPE_NAME FLOATCONSTANT INTCONSTANT UINTCONSTANT BOOLCONSTANT
%token <lex> FIELD_SELECTION
%token <lex> LEFT_OP RIGHT_OP
%token <lex> INC_OP DEC_OP LE_OP GE_OP EQ_OP NE_OP
%token <lex> AND_OP OR_OP XOR_OP MUL_ASSIGN DIV_ASSIGN ADD_ASSIGN
%token <lex> MOD_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN XOR_ASSIGN OR_ASSIGN
%token <lex> SUB_ASSIGN

%token <lex> LEFT_PAREN RIGHT_PAREN LEFT_BRACKET RIGHT_BRACKET LEFT_BRACE RIGHT_BRACE DOT
%token <lex> COMMA COLON EQUAL SEMICOLON BANG DASH TILDE PLUS STAR SLASH PERCENT
%token <lex> LEFT_ANGLE RIGHT_ANGLE VERTICAL_BAR CARET AMPERSAND QUESTION

%type <interm> assignment_operator unary_operator
%type <interm.intermTypedNode> variable_identifier primary_expression postfix_expression
%type <interm.intermTypedNode> expression integer_expression assignment_expression
%type <interm.intermTypedNode> unary_expression multiplicative_expression additive_expression
%type <interm.intermTypedNode> relational_expression equality_expression
%type <interm.intermTypedNode> conditional_expression constant_expression
%type <interm.intermTypedNode> logical_or_expression logical_xor_expression logical_and_expression
%type <interm.intermTypedNode> shift_expression and_expression exclusive_or_expression inclusive_or_expression
%type <interm.intermTypedNode> function_call initializer condition conditionopt

%type <interm.intermNode> translation_unit function_definition
%type <interm.intermNode> statement simple_statement
%type <interm.intermAggregate>  statement_list compound_statement
%type <interm.intermNode> declaration_statement selection_statement expression_statement
%type <interm.intermNode> declaration external_declaration
%type <interm.intermNode> for_init_statement compound_statement_no_new_scope
%type <interm.nodePair> selection_rest_statement for_rest_statement
%type <interm.intermSwitch> switch_statement
%type <interm.intermCase> case_label
%type <interm.intermNode> iteration_statement jump_statement statement_no_new_scope statement_with_scope
%type <interm> single_declaration init_declarator_list

%type <interm> parameter_declaration parameter_declarator parameter_type_specifier
%type <interm.qualifier> parameter_qualifier parameter_type_qualifier
%type <interm.layoutQualifier> layout_qualifier layout_qualifier_id_list layout_qualifier_id

%type <interm.precision> precision_qualifier
%type <interm.type> type_qualifier fully_specified_type type_specifier storage_qualifier interpolation_qualifier
%type <interm.type> type_specifier_no_prec type_specifier_nonarray
%type <interm.type> struct_specifier
%type <interm.field> struct_declarator
%type <interm.fieldList> struct_declarator_list struct_declaration struct_declaration_list
%type <interm.function> function_header function_declarator function_identifier
%type <interm.function> function_header_with_parameters function_call_header
%type <interm> function_call_header_with_parameters function_call_header_no_parameters function_call_generic function_prototype
%type <interm> function_call_or_method

%type <lex> enter_struct

%start translation_unit
%%

variable_identifier
    : IDENTIFIER {
        // The symbol table search was done in the lexical phase
        const TSymbol* symbol = $1.symbol;
        const TVariable* variable;
        if (symbol == 0) {
            context->error(@1, "undeclared identifier", $1.string->c_str());
            context->recover();
            TType type(EbtFloat, EbpUndefined);
            TVariable* fakeVariable = new TVariable($1.string, type);
            context->symbolTable.declare(*fakeVariable);
            variable = fakeVariable;
        } else {
            // This identifier can only be a variable type symbol
            if (! symbol->isVariable()) {
                context->error(@1, "variable expected", $1.string->c_str());
                context->recover();
            }
            variable = static_cast<const TVariable*>(symbol);
        }

        // don't delete $1.string, it's used by error recovery, and the pool
        // pop will reclaim the memory

        if (variable->getType().getQualifier() == EvqConstExpr ) {
            ConstantUnion* constArray = variable->getConstPointer();
            TType t(variable->getType());
            $$ = context->intermediate.addConstantUnion(constArray, t, @1);
        } else
            $$ = context->intermediate.addSymbol(variable->getUniqueId(),
                                                     variable->getName(),
                                                     variable->getType(), @1);
    }
    ;

primary_expression
    : variable_identifier {
        $$ = $1;
    }
    | INTCONSTANT {
        ConstantUnion *unionArray = new ConstantUnion[1];
        unionArray->setIConst($1.i);
        $$ = context->intermediate.addConstantUnion(unionArray, TType(EbtInt, EbpUndefined, EvqConstExpr), @1);
    }
    | UINTCONSTANT {
        ConstantUnion *unionArray = new ConstantUnion[1];
        unionArray->setUConst($1.u);
        $$ = context->intermediate.addConstantUnion(unionArray, TType(EbtUInt, EbpUndefined, EvqConstExpr), @1);
    }
    | FLOATCONSTANT {
        ConstantUnion *unionArray = new ConstantUnion[1];
        unionArray->setFConst($1.f);
        $$ = context->intermediate.addConstantUnion(unionArray, TType(EbtFloat, EbpUndefined, EvqConstExpr), @1);
    }
    | BOOLCONSTANT {
        ConstantUnion *unionArray = new ConstantUnion[1];
        unionArray->setBConst($1.b);
        $$ = context->intermediate.addConstantUnion(unionArray, TType(EbtBool, EbpUndefined, EvqConstExpr), @1);
    }
    | LEFT_PAREN expression RIGHT_PAREN {
        $$ = $2;
    }
    ;

postfix_expression
    : primary_expression {
        $$ = $1;
    }
    | postfix_expression LEFT_BRACKET integer_expression RIGHT_BRACKET {
        $$ = context->addIndexExpression($1, @2, $3);
    }
    | function_call {
        $$ = $1;
    }
    | postfix_expression DOT FIELD_SELECTION {
        $$ = context->addFieldSelectionExpression($1, @2, *$3.string, @3);
    }
    | postfix_expression INC_OP {
        $$ = context->addUnaryMathLValue(EOpPostIncrement, $1, @2);
    }
    | postfix_expression DEC_OP {
        $$ = context->addUnaryMathLValue(EOpPostDecrement, $1, @2);
    }
    ;

integer_expression
    : expression {
        if (context->integerErrorCheck($1, "[]"))
            context->recover();
        $$ = $1;
    }
    ;

function_call
    : function_call_or_method {
        TFunction* fnCall = $1.function;
        TOperator op = fnCall->getBuiltInOp();

        if (op != EOpNull)
        {
            //
            // Then this should be a constructor.
            // Don't go through the symbol table for constructors.
            // Their parameters will be verified algorithmically.
            //
            TType type(EbtVoid, EbpUndefined);  // use this to get the type back
            if (context->constructorErrorCheck(@1, $1.intermNode, *fnCall, op, &type)) {
                $$ = 0;
            } else {
                //
                // It's a constructor, of type 'type'.
                //
                $$ = context->addConstructor($1.intermNode, &type, op, fnCall, @1);
            }

            if ($$ == 0) {
                context->recover();
                $$ = context->intermediate.setAggregateOperator(0, op, @1);
            }
            $$->setType(type);
        } else {
            //
            // Not a constructor.  Find it in the symbol table.
            //
            const TFunction* fnCandidate;
            bool builtIn;
            fnCandidate = context->findFunction(@1, fnCall, &builtIn);
            if (fnCandidate) {
                //
                // A declared function.
                //
                if (builtIn && !fnCandidate->getExtension().empty() &&
                    context->extensionErrorCheck(@1, fnCandidate->getExtension())) {
                    context->recover();
                }
                op = fnCandidate->getBuiltInOp();
                if (builtIn && op != EOpNull) {
                    //
                    // A function call mapped to a built-in operation.
                    //
                    if (fnCandidate->getParamCount() == 1) {
                        //
                        // Treat it like a built-in unary operator.
                        //
                        $$ = context->intermediate.addUnaryMath(op, $1.intermNode, 0);
                        if ($$ == 0)  {
                            std::stringstream extraInfoStream;
                            extraInfoStream << "built in unary operator function.  Type: " << static_cast<TIntermTyped*>($1.intermNode)->getCompleteString();
                            std::string extraInfo = extraInfoStream.str();
                            context->error($1.intermNode->getLine(), " wrong operand type", "Internal Error", extraInfo.c_str());
                            YYERROR;
                        }
                    } else {
                        $$ = context->intermediate.setAggregateOperator($1.intermAggregate, op, @1);
                    }
                } else {
                    // This is a real function call

                    $$ = context->intermediate.setAggregateOperator($1.intermAggregate, EOpFunctionCall, @1);
                    $$->setType(fnCandidate->getReturnType());

                    // this is how we know whether the given function is a builtIn function or a user defined function
                    // if builtIn == false, it's a userDefined -> could be an overloaded builtIn function also
                    // if builtIn == true, it's definitely a builtIn function with EOpNull
                    if (!builtIn)
                        $$->getAsAggregate()->setUserDefined();
                    $$->getAsAggregate()->setName(fnCandidate->getMangledName());

                    TQualifier qual;
                    for (size_t i = 0; i < fnCandidate->getParamCount(); ++i) {
                        qual = fnCandidate->getParam(i).type->getQualifier();
                        if (qual == EvqOut || qual == EvqInOut) {
                            if (context->lValueErrorCheck($$->getLine(), "assign", $$->getAsAggregate()->getSequence()[i]->getAsTyped())) {
                                context->error($1.intermNode->getLine(), "Constant value cannot be passed for 'out' or 'inout' parameters.", "Error");
                                context->recover();
                            }
                        }
                    }
                }
                $$->setType(fnCandidate->getReturnType());
            } else {
                // error message was put out by PaFindFunction()
                // Put on a dummy node for error recovery
                ConstantUnion *unionArray = new ConstantUnion[1];
                unionArray->setFConst(0.0f);
                $$ = context->intermediate.addConstantUnion(unionArray, TType(EbtFloat, EbpUndefined, EvqConstExpr), @1);
                context->recover();
            }
        }
        delete fnCall;
    }
    ;

function_call_or_method
    : function_call_generic {
        $$ = $1;
    }
    | postfix_expression DOT function_call_generic {
        context->error(@3, "methods are not supported", "");
        context->recover();
        $$ = $3;
    }
    ;

function_call_generic
    : function_call_header_with_parameters RIGHT_PAREN {
        $$ = $1;
        $$.line = @2;
    }
    | function_call_header_no_parameters RIGHT_PAREN {
        $$ = $1;
        $$.line = @2;
    }
    ;

function_call_header_no_parameters
    : function_call_header VOID_TYPE {
        $$.function = $1;
        $$.intermNode = 0;
    }
    | function_call_header {
        $$.function = $1;
        $$.intermNode = 0;
    }
    ;

function_call_header_with_parameters
    : function_call_header assignment_expression {
        TParameter param = { 0, new TType($2->getType()) };
        $1->addParameter(param);
        $$.function = $1;
        $$.intermNode = $2;
    }
    | function_call_header_with_parameters COMMA assignment_expression {
        TParameter param = { 0, new TType($3->getType()) };
        $1.function->addParameter(param);
        $$.function = $1.function;
        $$.intermNode = context->intermediate.growAggregate($1.intermNode, $3, @2);
    }
    ;

function_call_header
    : function_identifier LEFT_PAREN {
        $$ = $1;
    }
    ;

// Grammar Note:  Constructors look like functions, but are recognized as types.

function_identifier
    : type_specifier_nonarray {
        //
        // Constructor
        //
        TOperator op = EOpNull;
        if ($1.userDef) {
            op = EOpConstructStruct;
        } else {
            switch ($1.type) {
            case EbtFloat:
                switch($1.primarySize) {
                case 1:
                    op = EOpConstructFloat; break;
                case 2:
                    switch($1.secondarySize) {
					case 1:                                 op = EOpConstructVec2;    break;
                    case 2:                                 op = EOpConstructMat2;    break;
                    case 3:                                 op = EOpConstructMat2x3;  break;
                    case 4:                                 op = EOpConstructMat2x4;  break;
                    }
                    break;
                case 3:
                    switch($1.secondarySize) {
					case 1:                                 op = EOpConstructVec3;    break;
                    case 2:                                 op = EOpConstructMat3x2;  break;
                    case 3:                                 op = EOpConstructMat3;    break;
                    case 4:                                 op = EOpConstructMat3x4;  break;
                    }
                    break;
                case 4:
                    switch($1.secondarySize) {
					case 1:                                 op = EOpConstructVec4;    break;
                    case 2:                                 op = EOpConstructMat4x2;  break;
                    case 3:                                 op = EOpConstructMat4x3;  break;
                    case 4:                                 op = EOpConstructMat4;    break;
                    }
                    break;
                }
                break;
            case EbtInt:
                switch($1.primarySize) {
                case 1:                                         op = EOpConstructInt;   break;
                case 2:       FRAG_VERT_ONLY("ivec2", @1); op = EOpConstructIVec2; break;
                case 3:       FRAG_VERT_ONLY("ivec3", @1); op = EOpConstructIVec3; break;
                case 4:       FRAG_VERT_ONLY("ivec4", @1); op = EOpConstructIVec4; break;
                }
                break;
            case EbtUInt:
                switch($1.primarySize) {
                case 1:                                         op = EOpConstructUInt;  break;
                case 2:       FRAG_VERT_ONLY("uvec2", @1); op = EOpConstructUVec2; break;
                case 3:       FRAG_VERT_ONLY("uvec3", @1); op = EOpConstructUVec3; break;
                case 4:       FRAG_VERT_ONLY("uvec4", @1); op = EOpConstructUVec4; break;
                }
                break;
            case EbtBool:
                switch($1.primarySize) {
                case 1:                                         op = EOpConstructBool;  break;
                case 2:       FRAG_VERT_ONLY("bvec2", @1); op = EOpConstructBVec2; break;
                case 3:       FRAG_VERT_ONLY("bvec3", @1); op = EOpConstructBVec3; break;
                case 4:       FRAG_VERT_ONLY("bvec4", @1); op = EOpConstructBVec4; break;
                }
                break;
            default: break;
            }
            if (op == EOpNull) {
                context->error(@1, "cannot construct this type", getBasicString($1.type));
                context->recover();
                $1.type = EbtFloat;
                op = EOpConstructFloat;
            }
        }
        TString tempString;
        TType type($1);
        TFunction *function = new TFunction(&tempString, type, op);
        $$ = function;
    }
    | IDENTIFIER {
        if (context->reservedErrorCheck(@1, *$1.string))
            context->recover();
        TType type(EbtVoid, EbpUndefined);
        TFunction *function = new TFunction($1.string, type);
        $$ = function;
    }
    | FIELD_SELECTION {
        if (context->reservedErrorCheck(@1, *$1.string))
            context->recover();
        TType type(EbtVoid, EbpUndefined);
        TFunction *function = new TFunction($1.string, type);
        $$ = function;
    }
    ;

unary_expression
    : postfix_expression {
        $$ = $1;
    }
    | INC_OP unary_expression {
        if (context->lValueErrorCheck(@1, "++", $2))
            context->recover();
        $$ = context->intermediate.addUnaryMath(EOpPreIncrement, $2, @1);
        if ($$ == 0) {
            context->unaryOpError(@1, "++", $2->getCompleteString());
            context->recover();
            $$ = $2;
        }
    }
    | DEC_OP unary_expression {
        if (context->lValueErrorCheck(@1, "--", $2))
            context->recover();
        $$ = context->intermediate.addUnaryMath(EOpPreDecrement, $2, @1);
        if ($$ == 0) {
            context->unaryOpError(@1, "--", $2->getCompleteString());
            context->recover();
            $$ = $2;
        }
    }
    | unary_operator unary_expression {
        if ($1.op != EOpNull) {
            $$ = context->intermediate.addUnaryMath($1.op, $2, @1);
            if ($$ == 0) {
                const char* errorOp = "";
                switch($1.op) {
                case EOpNegative:   errorOp = "-"; break;
                case EOpLogicalNot: errorOp = "!"; break;
                case EOpBitwiseNot: errorOp = "~"; break;
                default: break;
                }
                context->unaryOpError(@1, errorOp, $2->getCompleteString());
                context->recover();
                $$ = $2;
            }
        } else
            $$ = $2;
    }
    ;
// Grammar Note:  No traditional style type casts.

unary_operator
    : PLUS  { $$.line = @1; $$.op = EOpNull; }
    | DASH  { $$.line = @1; $$.op = EOpNegative; }
    | BANG  { $$.line = @1; $$.op = EOpLogicalNot; }
    | TILDE {
        ES3_ONLY("~", @1);
        $$.line = @1; $$.op = EOpBitwiseNot;
    }
    ;
// Grammar Note:  No '*' or '&' unary ops.  Pointers are not supported.

multiplicative_expression
    : unary_expression { $$ = $1; }
    | multiplicative_expression STAR unary_expression {
        FRAG_VERT_ONLY("*", @2);
        $$ = context->addBinaryMath(EOpMul, $1, $3, @2);
    }
    | multiplicative_expression SLASH unary_expression {
        FRAG_VERT_ONLY("/", @2);
        $$ = context->addBinaryMath(EOpDiv, $1, $3, @2);
    }
    | multiplicative_expression PERCENT unary_expression {
        FRAG_VERT_ONLY("%", @2);
        ES3_ONLY("%", @2);
        $$ = context->addBinaryMath(EOpIMod, $1, $3, @2);
    }
    ;

additive_expression
    : multiplicative_expression { $$ = $1; }
    | additive_expression PLUS multiplicative_expression {
        $$ = context->addBinaryMath(EOpAdd, $1, $3, @2);
    }
    | additive_expression DASH multiplicative_expression {
        $$ = context->addBinaryMath(EOpSub, $1, $3, @2);
    }
    ;

shift_expression
    : additive_expression { $$ = $1; }
    | shift_expression LEFT_OP additive_expression {
        ES3_ONLY("<<", @2);
        $$ = context->addBinaryMath(EOpBitShiftLeft, $1, $3, @2);
    }
    | shift_expression RIGHT_OP additive_expression {
        ES3_ONLY(">>", @2);
        $$ = context->addBinaryMath(EOpBitShiftRight, $1, $3, @2);
    }
    ;

relational_expression
    : shift_expression { $$ = $1; }
    | relational_expression LEFT_ANGLE shift_expression {
        $$ = context->addBinaryMathBooleanResult(EOpLessThan, $1, $3, @2);
    }
    | relational_expression RIGHT_ANGLE shift_expression  {
        $$ = context->addBinaryMathBooleanResult(EOpGreaterThan, $1, $3, @2);
    }
    | relational_expression LE_OP shift_expression  {
        $$ = context->addBinaryMathBooleanResult(EOpLessThanEqual, $1, $3, @2);
    }
    | relational_expression GE_OP shift_expression  {
        $$ = context->addBinaryMathBooleanResult(EOpGreaterThanEqual, $1, $3, @2);
    }
    ;

equality_expression
    : relational_expression { $$ = $1; }
    | equality_expression EQ_OP relational_expression  {
        $$ = context->addBinaryMathBooleanResult(EOpEqual, $1, $3, @2);
    }
    | equality_expression NE_OP relational_expression {
        $$ = context->addBinaryMathBooleanResult(EOpNotEqual, $1, $3, @2);
    }
    ;

and_expression
    : equality_expression { $$ = $1; }
    | and_expression AMPERSAND equality_expression {
        ES3_ONLY("&", @2);
        $$ = context->addBinaryMath(EOpBitwiseAnd, $1, $3, @2);
    }
    ;

exclusive_or_expression
    : and_expression { $$ = $1; }
    | exclusive_or_expression CARET and_expression {
        ES3_ONLY("^", @2);
        $$ = context->addBinaryMath(EOpBitwiseXor, $1, $3, @2);
    }
    ;

inclusive_or_expression
    : exclusive_or_expression { $$ = $1; }
    | inclusive_or_expression VERTICAL_BAR exclusive_or_expression {
        ES3_ONLY("|", @2);
        $$ = context->addBinaryMath(EOpBitwiseOr, $1, $3, @2);
    }
    ;

logical_and_expression
    : inclusive_or_expression { $$ = $1; }
    | logical_and_expression AND_OP inclusive_or_expression {
        $$ = context->addBinaryMathBooleanResult(EOpLogicalAnd, $1, $3, @2);
    }
    ;

logical_xor_expression
    : logical_and_expression { $$ = $1; }
    | logical_xor_expression XOR_OP logical_and_expression  {
        $$ = context->addBinaryMathBooleanResult(EOpLogicalXor, $1, $3, @2);
    }
    ;

logical_or_expression
    : logical_xor_expression { $$ = $1; }
    | logical_or_expression OR_OP logical_xor_expression  {
        $$ = context->addBinaryMathBooleanResult(EOpLogicalOr, $1, $3, @2);
    }
    ;

conditional_expression
    : logical_or_expression { $$ = $1; }
    | logical_or_expression QUESTION expression COLON assignment_expression {
       if (context->boolErrorCheck(@2, $1))
            context->recover();

        $$ = context->intermediate.addSelection($1, $3, $5, @2);
        if ($3->getType() != $5->getType())
            $$ = 0;

        if ($$ == 0) {
            context->binaryOpError(@2, ":", $3->getCompleteString(), $5->getCompleteString());
            context->recover();
            $$ = $5;
        }
    }
    ;

assignment_expression
    : conditional_expression { $$ = $1; }
    | unary_expression assignment_operator assignment_expression {
        if (context->lValueErrorCheck(@2, "assign", $1))
            context->recover();
        $$ = context->intermediate.addAssign($2.op, $1, $3, @2);
        if ($$ == 0) {
            context->assignError(@2, "assign", $1->getCompleteString(), $3->getCompleteString());
            context->recover();
            $$ = $1;
        }
    }
    ;

assignment_operator
    : EQUAL        {                                    $$.line = @1; $$.op = EOpAssign; }
    | MUL_ASSIGN   { FRAG_VERT_ONLY("*=", @1);     $$.line = @1; $$.op = EOpMulAssign; }
    | DIV_ASSIGN   { FRAG_VERT_ONLY("/=", @1);     $$.line = @1; $$.op = EOpDivAssign; }
    | MOD_ASSIGN   { ES3_ONLY("%=", @1); 
                     FRAG_VERT_ONLY("%=", @1);     $$.line = @1; $$.op = EOpIModAssign; }
    | ADD_ASSIGN   {                                    $$.line = @1; $$.op = EOpAddAssign; }
    | SUB_ASSIGN   {                                    $$.line = @1; $$.op = EOpSubAssign; }
    | LEFT_ASSIGN  { ES3_ONLY("<<=", @1);
                     FRAG_VERT_ONLY("<<=", @1);    $$.line = @1; $$.op = EOpBitShiftLeftAssign; }
    | RIGHT_ASSIGN { ES3_ONLY(">>=", @1);
                     FRAG_VERT_ONLY(">>=", @1);    $$.line = @1; $$.op = EOpBitShiftRightAssign; }
    | AND_ASSIGN   { ES3_ONLY("&=", @1);
                     FRAG_VERT_ONLY("&=", @1);     $$.line = @1; $$.op = EOpBitwiseAndAssign; }
    | XOR_ASSIGN   { ES3_ONLY("^=", @1);
                     FRAG_VERT_ONLY("^=", @1);     $$.line = @1; $$.op = EOpBitwiseXorAssign; }
    | OR_ASSIGN    { ES3_ONLY("|=", @1);
                     FRAG_VERT_ONLY("|=", @1);     $$.line = @1; $$.op = EOpBitwiseOrAssign; }
    ;

expression
    : assignment_expression {
        $$ = $1;
    }
    | expression COMMA assignment_expression {
        $$ = context->intermediate.addComma($1, $3, @2);
        if ($$ == 0) {
            context->binaryOpError(@2, ",", $1->getCompleteString(), $3->getCompleteString());
            context->recover();
            $$ = $3;
        }
    }
    ;

constant_expression
    : conditional_expression {
        if (context->constErrorCheck($1))
            context->recover();
        $$ = $1;
    }
    ;

enter_struct
    : IDENTIFIER LEFT_BRACE {
        if (context->enterStructDeclaration($1.line, *$1.string))
            context->recover();
        $$ = $1;
    }
    ;

declaration
    : function_prototype SEMICOLON   {
        TFunction &function = *($1.function);
        
        TIntermAggregate *prototype = new TIntermAggregate;
        prototype->setType(function.getReturnType());
        prototype->setName(function.getName());
        
        for (size_t i = 0; i < function.getParamCount(); i++)
        {
            const TParameter &param = function.getParam(i);
            if (param.name != 0)
            {
                TVariable variable(param.name, *param.type);
                
                prototype = context->intermediate.growAggregate(prototype, context->intermediate.addSymbol(variable.getUniqueId(), variable.getName(), variable.getType(), @1), @1);
            }
            else
            {
                prototype = context->intermediate.growAggregate(prototype, context->intermediate.addSymbol(0, "", *param.type, @1), @1);
            }
        }
        
        prototype->setOp(EOpPrototype);
        $$ = prototype;

        context->symbolTable.pop();
    }
    | init_declarator_list SEMICOLON {
        TIntermAggregate *aggNode = $1.intermAggregate;
        if (aggNode && aggNode->getOp() == EOpNull)
            aggNode->setOp(EOpDeclaration);
        $$ = aggNode;
    }
    | PRECISION precision_qualifier type_specifier_no_prec SEMICOLON {
        if (!context->symbolTable.setDefaultPrecision( $3, $2 )) {
            context->error(@1, "illegal type argument for default precision qualifier", getBasicString($3.type));
            context->recover();
        }
        $$ = 0;
    }
    | type_qualifier enter_struct struct_declaration_list RIGHT_BRACE SEMICOLON {
        ES3_ONLY(getQualifierString($1.qualifier), $1.line);
        $$ = context->addInterfaceBlock($1, $2.line, *$2.string, $3, NULL, $1.line, NULL, $1.line);
    }
    | type_qualifier enter_struct struct_declaration_list RIGHT_BRACE IDENTIFIER SEMICOLON {
        ES3_ONLY(getQualifierString($1.qualifier), $1.line);
        $$ = context->addInterfaceBlock($1, $2.line, *$2.string, $3, $5.string, $5.line, NULL, $1.line);
    }
    | type_qualifier enter_struct struct_declaration_list RIGHT_BRACE IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET SEMICOLON {
        ES3_ONLY(getQualifierString($1.qualifier), $1.line);
        $$ = context->addInterfaceBlock($1, $2.line, *$2.string, $3, $5.string, $5.line, $7, $6.line);
    }
    | type_qualifier SEMICOLON {
        context->parseGlobalLayoutQualifier($1);
        $$ = 0;
    }
    ;

function_prototype
    : function_declarator RIGHT_PAREN  {
        //
        // Multiple declarations of the same function are allowed.
        //
        // If this is a definition, the definition production code will check for redefinitions
        // (we don't know at this point if it's a definition or not).
        //
        // Redeclarations are allowed.  But, return types and parameter qualifiers must match.
        //
        TFunction* prevDec = static_cast<TFunction*>(context->symbolTable.find($1->getMangledName(), context->shaderVersion));
        if (prevDec) {
            if (prevDec->getReturnType() != $1->getReturnType()) {
                context->error(@2, "overloaded functions must have the same return type", $1->getReturnType().getBasicString());
                context->recover();
            }
            for (size_t i = 0; i < prevDec->getParamCount(); ++i) {
                if (prevDec->getParam(i).type->getQualifier() != $1->getParam(i).type->getQualifier()) {
                    context->error(@2, "overloaded functions must have the same parameter qualifiers", $1->getParam(i).type->getQualifierString());
                    context->recover();
                }
            }
        }

        //
        // If this is a redeclaration, it could also be a definition,
        // in which case, we want to use the variable names from this one, and not the one that's
        // being redeclared.  So, pass back up this declaration, not the one in the symbol table.
        //
        $$.function = $1;
        $$.line = @2;

        // We're at the inner scope level of the function's arguments and body statement.
        // Add the function prototype to the surrounding scope instead.
        context->symbolTable.getOuterLevel()->insert(*$$.function);
    }
    ;

function_declarator
    : function_header {
        $$ = $1;
    }
    | function_header_with_parameters {
        $$ = $1;
    }
    ;


function_header_with_parameters
    : function_header parameter_declaration {
        // Add the parameter
        $$ = $1;
        if ($2.param.type->getBasicType() != EbtVoid)
            $1->addParameter($2.param);
        else
            delete $2.param.type;
    }
    | function_header_with_parameters COMMA parameter_declaration {
        //
        // Only first parameter of one-parameter functions can be void
        // The check for named parameters not being void is done in parameter_declarator
        //
        if ($3.param.type->getBasicType() == EbtVoid) {
            //
            // This parameter > first is void
            //
            context->error(@2, "cannot be an argument type except for '(void)'", "void");
            context->recover();
            delete $3.param.type;
        } else {
            // Add the parameter
            $$ = $1;
            $1->addParameter($3.param);
        }
    }
    ;

function_header
    : fully_specified_type IDENTIFIER LEFT_PAREN {
        if ($1.qualifier != EvqGlobal && $1.qualifier != EvqTemporary) {
            context->error(@2, "no qualifiers allowed for function return", getQualifierString($1.qualifier));
            context->recover();
        }
        // make sure a sampler is not involved as well...
        if (context->structQualifierErrorCheck(@2, $1))
            context->recover();

        // Add the function as a prototype after parsing it (we do not support recursion)
        TFunction *function;
        TType type($1);
        function = new TFunction($2.string, type);
        $$ = function;
        
        context->symbolTable.push();
    }
    ;

parameter_declarator
    // Type + name
    : type_specifier IDENTIFIER {
        if ($1.type == EbtVoid) {
            context->error(@2, "illegal use of type 'void'", $2.string->c_str());
            context->recover();
        }
        if (context->reservedErrorCheck(@2, *$2.string))
            context->recover();
        TParameter param = {$2.string, new TType($1)};
        $$.line = @2;
        $$.param = param;
    }
    | type_specifier IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET {
        // Check that we can make an array out of this type
        if (context->arrayTypeErrorCheck(@3, $1))
            context->recover();

        if (context->reservedErrorCheck(@2, *$2.string))
            context->recover();

        int size;
        if (context->arraySizeErrorCheck(@3, $4, size))
            context->recover();
        $1.setArray(true, size);

        TType* type = new TType($1);
        TParameter param = { $2.string, type };
        $$.line = @2;
        $$.param = param;
    }
    ;

parameter_declaration
    //
    // The only parameter qualifier a parameter can have are
    // IN_QUAL, OUT_QUAL, INOUT_QUAL, or CONST.
    //

    //
    // Type + name
    //
    : parameter_type_qualifier parameter_qualifier parameter_declarator {
        $$ = $3;
        if (context->paramErrorCheck(@3, $1, $2, $$.param.type))
            context->recover();
    }
    | parameter_qualifier parameter_declarator {
        $$ = $2;
        if (context->parameterSamplerErrorCheck(@2, $1, *$2.param.type))
            context->recover();
        if (context->paramErrorCheck(@2, EvqTemporary, $1, $$.param.type))
            context->recover();
    }
    //
    // Only type
    //
    | parameter_type_qualifier parameter_qualifier parameter_type_specifier {
        $$ = $3;
        if (context->paramErrorCheck(@3, $1, $2, $$.param.type))
            context->recover();
    }
    | parameter_qualifier parameter_type_specifier {
        $$ = $2;
        if (context->parameterSamplerErrorCheck(@2, $1, *$2.param.type))
            context->recover();
        if (context->paramErrorCheck(@2, EvqTemporary, $1, $$.param.type))
            context->recover();
    }
    ;

parameter_qualifier
    : /* empty */ {
        $$ = EvqIn;
    }
    | IN_QUAL {
        $$ = EvqIn;
    }
    | OUT_QUAL {
        $$ = EvqOut;
    }
    | INOUT_QUAL {
        $$ = EvqInOut;
    }
    ;

parameter_type_specifier
    : type_specifier {
        TParameter param = { 0, new TType($1) };
        $$.param = param;
    }
    ;

init_declarator_list
    : single_declaration {
        $$ = $1;
    }
    | init_declarator_list COMMA IDENTIFIER {
        $$ = $1;
        $$.intermAggregate = context->parseDeclarator($$.type, $1.intermAggregate, @3, *$3.string);
    }
    | init_declarator_list COMMA IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET {
        $$ = $1;
        $$.intermAggregate = context->parseArrayDeclarator($$.type, $1.intermAggregate, @3, *$3.string, @4, $5);
    }
    | init_declarator_list COMMA IDENTIFIER LEFT_BRACKET RIGHT_BRACKET EQUAL initializer {
        ES3_ONLY("[]", @3);
        $$ = $1;
        $$.intermAggregate = context->parseArrayInitDeclarator($$.type, $1.intermAggregate, @3, *$3.string, @4, nullptr, @6, $7);
    }
    | init_declarator_list COMMA IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET EQUAL initializer {
        ES3_ONLY("=", @7);
        $$ = $1;
        $$.intermAggregate = context->parseArrayInitDeclarator($$.type, $1.intermAggregate, @3, *$3.string, @4, $5, @7, $8);
    }
    | init_declarator_list COMMA IDENTIFIER EQUAL initializer {
        $$ = $1;
        $$.intermAggregate = context->parseInitDeclarator($$.type, $1.intermAggregate, @3, *$3.string, @4, $5);
    }
    ;

single_declaration
    : fully_specified_type {
        $$.type = $1;
        $$.intermAggregate = context->parseSingleDeclaration($$.type, @1, "");
    }
    | fully_specified_type IDENTIFIER {
        $$.type = $1;
        $$.intermAggregate = context->parseSingleDeclaration($$.type, @2, *$2.string);
    }
    | fully_specified_type IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET {
        $$.type = $1;
        $$.intermAggregate = context->parseSingleArrayDeclaration($$.type, @2, *$2.string, @3, $4);
    }
    | fully_specified_type IDENTIFIER LEFT_BRACKET RIGHT_BRACKET EQUAL initializer {
        ES3_ONLY("[]", @3);
        $$.type = $1;
        $$.intermAggregate = context->parseSingleArrayInitDeclaration($$.type, @2, *$2.string, @3, nullptr, @5, $6);
    }
    | fully_specified_type IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET EQUAL initializer {
        ES3_ONLY("=", @6);
        $$.type = $1;
        $$.intermAggregate = context->parseSingleArrayInitDeclaration($$.type, @2, *$2.string, @3, $4, @6, $7);
    }
    | fully_specified_type IDENTIFIER EQUAL initializer {
        $$.type = $1;
        $$.intermAggregate = context->parseSingleInitDeclaration($$.type, @2, *$2.string, @3, $4);
    }
    | INVARIANT IDENTIFIER {
        // $$.type is not used in invariant declarations.
        $$.intermAggregate = context->parseInvariantDeclaration(@1, @2, $2.string, $2.symbol);
    }
    ;

//
// Place holder for the pack/unpack languages.
//
//    | buffer_specifier {
//        $$.intermAggregate = 0;
//    }
    ;

// Grammar Note:  No 'enum', or 'typedef'.

//
// Place holder for the pack/unpack languages.
//
//%type <interm> buffer_declaration
//%type <interm.type> buffer_specifier input_or_output buffer_declaration_list
//buffer_specifier
//    : input_or_output LEFT_BRACE buffer_declaration_list RIGHT_BRACE {
//    }
//    ;
//
//input_or_output
//    : INPUT {
//        if (context->globalErrorCheck(@1, context->symbolTable.atGlobalLevel(), "input"))
//            context->recover();
//        UNPACK_ONLY("input", @1);
//        $$.qualifier = EvqInput;
//    }
//    | OUTPUT {
//        if (context->globalErrorCheck(@1, context->symbolTable.atGlobalLevel(), "output"))
//            context->recover();
//        PACK_ONLY("output", @1);
//        $$.qualifier = EvqOutput;
//    }
//    ;

//
// Place holder for the pack/unpack languages.
//
//buffer_declaration_list
//    : buffer_declaration {
//    }
//    | buffer_declaration_list buffer_declaration {
//    }
//    ;

//
// Input/output semantics:
//   float must be 16 or 32 bits
//   float alignment restrictions?
//   check for only one input and only one output
//   sum of bitfields has to be multiple of 32
//

//
// Place holder for the pack/unpack languages.
//
//buffer_declaration
//    : type_specifier IDENTIFIER COLON constant_expression SEMICOLON {
//        if (context->reservedErrorCheck(@2, *$2.string, context))
//            context->recover();
//        $$.variable = new TVariable($2.string, $1);
//        if (! context->symbolTable.declare(*$$.variable)) {
//            context->error(@2, "redefinition", $$.variable->getName().c_str());
//            context->recover();
//            // don't have to delete $$.variable, the pool pop will take care of it
//        }
//    }
//    ;

fully_specified_type
    : type_specifier {
        $$ = $1;

        if ($1.array) {
            ES3_ONLY("[]", @1);
            if (context->getShaderVersion() != 300) {
                $1.clearArrayness();
            }
        }
    }
    | type_qualifier type_specifier  {
        $$ = context->addFullySpecifiedType($1.qualifier, $1.invariant, $1.layoutQualifier, $2);
    }
    ;

interpolation_qualifier
    : SMOOTH {
        $$.qualifier = EvqSmooth;
    }
    | FLAT {
        $$.qualifier = EvqFlat;
    }
    ;

parameter_type_qualifier
    : CONST_QUAL {
        $$ = EvqConstReadOnly;
    }
    ;

type_qualifier
    : ATTRIBUTE {
        VERTEX_ONLY("attribute", @1);
        ES2_ONLY("attribute", @1);
        if (context->globalErrorCheck(@1, context->symbolTable.atGlobalLevel(), "attribute"))
            context->recover();
        $$.setBasic(EbtVoid, EvqAttribute, @1);
    }
    | VARYING {
        ES2_ONLY("varying", @1);
        if (context->globalErrorCheck(@1, context->symbolTable.atGlobalLevel(), "varying"))
            context->recover();
        if (context->shaderType == GL_VERTEX_SHADER)
            $$.setBasic(EbtVoid, EvqVaryingOut, @1);
        else
            $$.setBasic(EbtVoid, EvqVaryingIn, @1);
    }
    | INVARIANT VARYING {
        ES2_ONLY("varying", @1);
        if (context->globalErrorCheck(@1, context->symbolTable.atGlobalLevel(), "invariant varying"))
            context->recover();
        if (context->shaderType == GL_VERTEX_SHADER)
            $$.setBasic(EbtVoid, EvqInvariantVaryingOut, @1);
        else
            $$.setBasic(EbtVoid, EvqInvariantVaryingIn, @1);
    }
	| storage_qualifier {
        $$.setBasic(EbtVoid, $1.qualifier, @1);
    }
	| interpolation_qualifier storage_qualifier {
        $$ = context->joinInterpolationQualifiers(@1, $1.qualifier, @2, $2.qualifier);
    }
    | interpolation_qualifier {
        context->error(@1, "interpolation qualifier requires a fragment 'in' or vertex 'out' storage qualifier", getQualifierString($1.qualifier));
        context->recover();
        
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtVoid, qual, @1);
    }
	| layout_qualifier {
        $$.qualifier = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.layoutQualifier = $1;
    }
    | layout_qualifier storage_qualifier {
        $$.setBasic(EbtVoid, $2.qualifier, @2);
        $$.layoutQualifier = $1;
    }
    ;

storage_qualifier
    : CONST_QUAL {
        $$.qualifier = EvqConstExpr;
		$$.line = @1;
    }
    | IN_QUAL {
		ES3_ONLY("in", @1);
        $$.qualifier = (context->shaderType == GL_FRAGMENT_SHADER) ? EvqFragmentIn : EvqVertexIn;
		$$.line = @1;
    }
    | OUT_QUAL {
		ES3_ONLY("out", @1);
        $$.qualifier = (context->shaderType == GL_FRAGMENT_SHADER) ? EvqFragmentOut : EvqVertexOut;
		$$.line = @1;
    }
    | CENTROID IN_QUAL {
		ES3_ONLY("centroid in", @1);
        if (context->shaderType == GL_VERTEX_SHADER)
        {
            context->error(@1, "invalid storage qualifier", "it is an error to use 'centroid in' in the vertex shader");
            context->recover();
        }
        $$.qualifier = (context->shaderType == GL_FRAGMENT_SHADER) ? EvqCentroidIn : EvqVertexIn;
		$$.line = @2;
    }
	| CENTROID OUT_QUAL {
		ES3_ONLY("centroid out", @1);
        if (context->shaderType == GL_FRAGMENT_SHADER)
        {
            context->error(@1, "invalid storage qualifier", "it is an error to use 'centroid out' in the fragment shader");
            context->recover();
        }
        $$.qualifier = (context->shaderType == GL_FRAGMENT_SHADER) ? EvqFragmentOut : EvqCentroidOut;
		$$.line = @2;
    }
	| UNIFORM {
        if (context->globalErrorCheck(@1, context->symbolTable.atGlobalLevel(), "uniform"))
            context->recover();
        $$.qualifier = EvqUniform;
		$$.line = @1;
    }
    ;

type_specifier
    : type_specifier_no_prec {
        $$ = $1;

        if ($$.precision == EbpUndefined) {
            $$.precision = context->symbolTable.getDefaultPrecision($1.type);
            if (context->precisionErrorCheck(@1, $$.precision, $1.type)) {
                context->recover();
            }
        }
    }
    | precision_qualifier type_specifier_no_prec {
        $$ = $2;
        $$.precision = $1;
    }
    ;

precision_qualifier
    : HIGH_PRECISION {
        $$ = EbpHigh;
    }
    | MEDIUM_PRECISION {
        $$ = EbpMedium;
    }
    | LOW_PRECISION  {
        $$ = EbpLow;
    }
    ;

layout_qualifier
    : LAYOUT LEFT_PAREN layout_qualifier_id_list RIGHT_PAREN {
        ES3_ONLY("layout", @1);
        $$ = $3;
    }
    ;

layout_qualifier_id_list
    : layout_qualifier_id {
        $$ = $1;
    }
    | layout_qualifier_id_list COMMA layout_qualifier_id {
        $$ = context->joinLayoutQualifiers($1, $3);
    }
    ;

layout_qualifier_id
    : IDENTIFIER {
        $$ = context->parseLayoutQualifier(*$1.string, @1);
    }
    | IDENTIFIER EQUAL INTCONSTANT {
        $$ = context->parseLayoutQualifier(*$1.string, @1, *$3.string, $3.i, @3);
    }
    | IDENTIFIER EQUAL UINTCONSTANT {
        $$ = context->parseLayoutQualifier(*$1.string, @1, *$3.string, $3.i, @3);
    }
    ;

type_specifier_no_prec
    : type_specifier_nonarray {
        $$ = $1;
    }
    | type_specifier_nonarray LEFT_BRACKET constant_expression RIGHT_BRACKET {
        $$ = $1;

        if (context->arrayTypeErrorCheck(@2, $1))
            context->recover();
        else {
            int size;
            if (context->arraySizeErrorCheck(@2, $3, size))
                context->recover();
            $$.setArray(true, size);
        }
    }
    ;

type_specifier_nonarray
    : VOID_TYPE {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtVoid, qual, @1);
    }
    | FLOAT_TYPE {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
    }
    | INT_TYPE {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtInt, qual, @1);
    }
    | UINT_TYPE {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtUInt, qual, @1);
    }
    | BOOL_TYPE {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtBool, qual, @1);
    }
    | VEC2 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setAggregate(2);
    }
    | VEC3 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setAggregate(3);
    }
    | VEC4 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setAggregate(4);
    }
    | BVEC2 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtBool, qual, @1);
        $$.setAggregate(2);
    }
    | BVEC3 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtBool, qual, @1);
        $$.setAggregate(3);
    }
    | BVEC4 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtBool, qual, @1);
        $$.setAggregate(4);
    }
    | IVEC2 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtInt, qual, @1);
        $$.setAggregate(2);
    }
    | IVEC3 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtInt, qual, @1);
        $$.setAggregate(3);
    }
    | IVEC4 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtInt, qual, @1);
        $$.setAggregate(4);
    }
    | UVEC2 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtUInt, qual, @1);
        $$.setAggregate(2);
    }
    | UVEC3 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtUInt, qual, @1);
        $$.setAggregate(3);
    }
    | UVEC4 {
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtUInt, qual, @1);
        $$.setAggregate(4);
    }
    | MATRIX2 {
        FRAG_VERT_ONLY("mat2", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setMatrix(2, 2);
    }
    | MATRIX3 {
        FRAG_VERT_ONLY("mat3", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setMatrix(3, 3);
    }
    | MATRIX4 {
        FRAG_VERT_ONLY("mat4", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setMatrix(4, 4);
    }
    | MATRIX2x3 {
        FRAG_VERT_ONLY("mat2x3", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setMatrix(2, 3);
    }
    | MATRIX3x2 {
        FRAG_VERT_ONLY("mat3x2", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setMatrix(3, 2);
    }
    | MATRIX2x4 {
        FRAG_VERT_ONLY("mat2x4", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setMatrix(2, 4);
    }
    | MATRIX4x2 {
        FRAG_VERT_ONLY("mat4x2", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setMatrix(4, 2);
    }
    | MATRIX3x4 {
        FRAG_VERT_ONLY("mat3x4", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setMatrix(3, 4);
    }
    | MATRIX4x3 {
        FRAG_VERT_ONLY("mat4x3", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtFloat, qual, @1);
        $$.setMatrix(4, 3);
    }
    | SAMPLER2D {
        FRAG_VERT_ONLY("sampler2D", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtSampler2D, qual, @1);
    }
    | SAMPLERCUBE {
        FRAG_VERT_ONLY("samplerCube", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtSamplerCube, qual, @1);
    }
	| SAMPLER_EXTERNAL_OES {
        if (!context->supportsExtension("GL_OES_EGL_image_external")) {
            context->error(@1, "unsupported type", "samplerExternalOES", "");
            context->recover();
        }
        FRAG_VERT_ONLY("samplerExternalOES", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtSamplerExternalOES, qual, @1);
    }
    | SAMPLER3D {
        FRAG_VERT_ONLY("sampler3D", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtSampler3D, qual, @1);
    }
    | SAMPLER2DARRAY {
        FRAG_VERT_ONLY("sampler2DArray", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtSampler2DArray, qual, @1);
    }
    | ISAMPLER2D {
        FRAG_VERT_ONLY("isampler2D", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtISampler2D, qual, @1);
    }
    | ISAMPLER3D {
        FRAG_VERT_ONLY("isampler3D", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtISampler3D, qual, @1);
    }
    | ISAMPLERCUBE {
        FRAG_VERT_ONLY("isamplerCube", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtISamplerCube, qual, @1);
    }
    | ISAMPLER2DARRAY {
        FRAG_VERT_ONLY("isampler2DArray", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtISampler2DArray, qual, @1);
    }
    | USAMPLER2D {
        FRAG_VERT_ONLY("usampler2D", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtUSampler2D, qual, @1);
    }
    | USAMPLER3D {
        FRAG_VERT_ONLY("usampler3D", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtUSampler3D, qual, @1);
    }
    | USAMPLERCUBE {
        FRAG_VERT_ONLY("usamplerCube", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtUSamplerCube, qual, @1);
    }
    | USAMPLER2DARRAY {
        FRAG_VERT_ONLY("usampler2DArray", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtUSampler2DArray, qual, @1);
    }
    | SAMPLER2DSHADOW {
        FRAG_VERT_ONLY("sampler2DShadow", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtSampler2DShadow, qual, @1);
    }
    | SAMPLERCUBESHADOW {
        FRAG_VERT_ONLY("samplerCubeShadow", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtSamplerCubeShadow, qual, @1);
    }
    | SAMPLER2DARRAYSHADOW {
        FRAG_VERT_ONLY("sampler2DArrayShadow", @1);
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtSampler2DArrayShadow, qual, @1);
    }
    | struct_specifier {
        FRAG_VERT_ONLY("struct", @1);
        $$ = $1;
        $$.qualifier = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
    }
    | TYPE_NAME {
        //
        // This is for user defined type names.  The lexical phase looked up the
        // type.
        //
        TType& structure = static_cast<TVariable*>($1.symbol)->getType();
        TQualifier qual = context->symbolTable.atGlobalLevel() ? EvqGlobal : EvqTemporary;
        $$.setBasic(EbtStruct, qual, @1);
        $$.userDef = &structure;
    }
    ;

struct_specifier
    : STRUCT IDENTIFIER LEFT_BRACE { if (context->enterStructDeclaration(@2, *$2.string)) context->recover(); } struct_declaration_list RIGHT_BRACE {
        $$ = context->addStructure(@1, @2, $2.string, $5);
    }
    | STRUCT LEFT_BRACE { if (context->enterStructDeclaration(@2, *$2.string)) context->recover(); } struct_declaration_list RIGHT_BRACE {
        $$ = context->addStructure(@1, @1, NewPoolTString(""), $4);
    }
    ;

struct_declaration_list
    : struct_declaration {
        $$ = $1;
    }
    | struct_declaration_list struct_declaration {
        $$ = $1;
        for (unsigned int i = 0; i < $2->size(); ++i) {
            TField* field = (*$2)[i];
            for (unsigned int j = 0; j < $$->size(); ++j) {
                if ((*$$)[j]->name() == field->name()) {
                    context->error((*$2)[i]->line(), "duplicate field name in structure:", "struct", field->name().c_str());
                    context->recover();
                }
            }
            $$->push_back((*$2)[i]);
        }
    }
    ;

struct_declaration
    : type_specifier struct_declarator_list SEMICOLON {
        $$ = context->addStructDeclaratorList($1, $2);
    }
    | type_qualifier type_specifier struct_declarator_list SEMICOLON {
        // ES3 Only, but errors should be handled elsewhere
        $2.qualifier = $1.qualifier;
        $2.layoutQualifier = $1.layoutQualifier;
        $$ = context->addStructDeclaratorList($2, $3);
    }
    ;

struct_declarator_list
    : struct_declarator {
        $$ = NewPoolTFieldList();
        $$->push_back($1);
    }
    | struct_declarator_list COMMA struct_declarator {
        $$->push_back($3);
    }
    ;

struct_declarator
    : IDENTIFIER {
        if (context->reservedErrorCheck(@1, *$1.string))
            context->recover();

        TType* type = new TType(EbtVoid, EbpUndefined);
        $$ = new TField(type, $1.string, @1);
    }
    | IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET {
        if (context->reservedErrorCheck(@1, *$1.string))
            context->recover();

        TType* type = new TType(EbtVoid, EbpUndefined);
        int size;
        if (context->arraySizeErrorCheck($3->getLine(), $3, size))
            context->recover();
        type->setArraySize(size);

        $$ = new TField(type, $1.string, @1);
    }
    ;

initializer
    : assignment_expression { $$ = $1; }
    ;

declaration_statement
    : declaration { $$ = $1; }
    ;

statement
    : compound_statement  { $$ = $1; }
    | simple_statement    { $$ = $1; }
    ;

// Grammar Note:  No labeled statements; 'goto' is not supported.

simple_statement
    : declaration_statement { $$ = $1; }
    | expression_statement  { $$ = $1; }
    | selection_statement   { $$ = $1; }
    | switch_statement      { $$ = $1; }
    | case_label            { $$ = $1; }
    | iteration_statement   { $$ = $1; }
    | jump_statement        { $$ = $1; }
    ;

compound_statement
    : LEFT_BRACE RIGHT_BRACE { $$ = 0; }
    | LEFT_BRACE { context->symbolTable.push(); } statement_list { context->symbolTable.pop(); } RIGHT_BRACE {
        if ($3 != 0) {
            $3->setOp(EOpSequence);
            $3->setEndLine(@5);
        }
        $$ = $3;
    }
    ;

statement_no_new_scope
    : compound_statement_no_new_scope { $$ = $1; }
    | simple_statement                { $$ = $1; }
    ;

statement_with_scope
    : { context->symbolTable.push(); } compound_statement_no_new_scope { context->symbolTable.pop(); $$ = $2; }
    | { context->symbolTable.push(); } simple_statement                { context->symbolTable.pop(); $$ = $2; }
    ;

compound_statement_no_new_scope
    // Statement that doesn't create a new scope, for selection_statement, iteration_statement
    : LEFT_BRACE RIGHT_BRACE {
        $$ = 0;
    }
    | LEFT_BRACE statement_list RIGHT_BRACE {
        if ($2) {
            $2->setOp(EOpSequence);
            $2->setEndLine(@3);
        }
        $$ = $2;
    }
    ;

statement_list
    : statement {
        $$ = context->intermediate.makeAggregate($1, 0);
    }
    | statement_list statement {
        $$ = context->intermediate.growAggregate($1, $2, 0);
    }
    ;

expression_statement
    : SEMICOLON  { $$ = 0; }
    | expression SEMICOLON  { $$ = static_cast<TIntermNode*>($1); }
    ;

selection_statement
    : IF LEFT_PAREN expression RIGHT_PAREN selection_rest_statement {
        if (context->boolErrorCheck(@1, $3))
            context->recover();
        $$ = context->intermediate.addSelection($3, $5, @1);
    }
    ;

selection_rest_statement
    : statement_with_scope ELSE statement_with_scope {
        $$.node1 = $1;
        $$.node2 = $3;
    }
    | statement_with_scope {
        $$.node1 = $1;
        $$.node2 = 0;
    }
    ;

switch_statement
    : SWITCH LEFT_PAREN expression RIGHT_PAREN { context->incrSwitchNestingLevel(); } compound_statement {
        $$ = context->addSwitch($3, $6, $1.line);
        context->decrSwitchNestingLevel();
    }
    ;

case_label
    : CASE constant_expression COLON {
        $$ = context->addCase($2, $1.line);
    }
    | DEFAULT COLON {
        $$ = context->addDefault($1.line);
    }
    ;

// Grammar Note:  Labeled statements for SWITCH only; 'goto' is not supported.

condition
    // In 1996 c++ draft, conditions can include single declarations
    : expression {
        $$ = $1;
        if (context->boolErrorCheck($1->getLine(), $1))
            context->recover();
    }
    | fully_specified_type IDENTIFIER EQUAL initializer {
        TIntermNode* intermNode;
        if (context->structQualifierErrorCheck(@2, $1))
            context->recover();
        if (context->boolErrorCheck(@2, $1))
            context->recover();

        if (!context->executeInitializer(@2, *$2.string, $1, $4, intermNode))
            $$ = $4;
        else {
            context->recover();
            $$ = 0;
        }
    }
    ;

iteration_statement
    : WHILE LEFT_PAREN { context->symbolTable.push(); ++context->loopNestingLevel; } condition RIGHT_PAREN statement_no_new_scope {
        context->symbolTable.pop();
        $$ = context->intermediate.addLoop(ELoopWhile, 0, $4, 0, $6, @1);
        --context->loopNestingLevel;
    }
    | DO { ++context->loopNestingLevel; } statement_with_scope WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON {
        if (context->boolErrorCheck(@8, $6))
            context->recover();

        $$ = context->intermediate.addLoop(ELoopDoWhile, 0, $6, 0, $3, @4);
        --context->loopNestingLevel;
    }
    | FOR LEFT_PAREN { context->symbolTable.push(); ++context->loopNestingLevel; } for_init_statement for_rest_statement RIGHT_PAREN statement_no_new_scope {
        context->symbolTable.pop();
        $$ = context->intermediate.addLoop(ELoopFor, $4, reinterpret_cast<TIntermTyped*>($5.node1), reinterpret_cast<TIntermTyped*>($5.node2), $7, @1);
        --context->loopNestingLevel;
    }
    ;

for_init_statement
    : expression_statement {
        $$ = $1;
    }
    | declaration_statement {
        $$ = $1;
    }
    ;

conditionopt
    : condition {
        $$ = $1;
    }
    | /* May be null */ {
        $$ = 0;
    }
    ;

for_rest_statement
    : conditionopt SEMICOLON {
        $$.node1 = $1;
        $$.node2 = 0;
    }
    | conditionopt SEMICOLON expression  {
        $$.node1 = $1;
        $$.node2 = $3;
    }
    ;

jump_statement
    : CONTINUE SEMICOLON {
        $$ = context->addBranch(EOpContinue, @1);
    }
    | BREAK SEMICOLON {
        $$ = context->addBranch(EOpBreak, @1);
    }
    | RETURN SEMICOLON {
        $$ = context->addBranch(EOpReturn, @1);
    }
    | RETURN expression SEMICOLON {
        $$ = context->addBranch(EOpReturn, $2, @1);
    }
    | DISCARD SEMICOLON {
        FRAG_ONLY("discard", @1);
        $$ = context->addBranch(EOpKill, @1);
    }
    ;

// Grammar Note:  No 'goto'.  Gotos are not supported.

translation_unit
    : external_declaration {
        $$ = $1;
        context->treeRoot = $$;
    }
    | translation_unit external_declaration {
        $$ = context->intermediate.growAggregate($1, $2, 0);
        context->treeRoot = $$;
    }
    ;

external_declaration
    : function_definition {
        $$ = $1;
    }
    | declaration {
        $$ = $1;
    }
    ;

function_definition
    : function_prototype {
        TFunction* function = $1.function;
        
        const TSymbol *builtIn = context->symbolTable.findBuiltIn(function->getMangledName(), context->shaderVersion);
        
        if (builtIn)
        {
            context->error(@1, "built-in functions cannot be redefined", function->getName().c_str());
            context->recover();
        }
        
        TFunction* prevDec = static_cast<TFunction*>(context->symbolTable.find(function->getMangledName(), context->shaderVersion));
        //
        // Note:  'prevDec' could be 'function' if this is the first time we've seen function
        // as it would have just been put in the symbol table.  Otherwise, we're looking up
        // an earlier occurance.
        //
        if (prevDec->isDefined()) {
            //
            // Then this function already has a body.
            //
            context->error(@1, "function already has a body", function->getName().c_str());
            context->recover();
        }
        prevDec->setDefined();

        //
        // Raise error message if main function takes any parameters or return anything other than void
        //
        if (function->getName() == "main") {
            if (function->getParamCount() > 0) {
                context->error(@1, "function cannot take any parameter(s)", function->getName().c_str());
                context->recover();
            }
            if (function->getReturnType().getBasicType() != EbtVoid) {
                context->error(@1, "", function->getReturnType().getBasicString(), "main function cannot return a value");
                context->recover();
            }
        }

        //
        // Remember the return type for later checking for RETURN statements.
        //
        context->currentFunctionType = &(prevDec->getReturnType());
        context->functionReturnsValue = false;

        //
        // Insert parameters into the symbol table.
        // If the parameter has no name, it's not an error, just don't insert it
        // (could be used for unused args).
        //
        // Also, accumulate the list of parameters into the HIL, so lower level code
        // knows where to find parameters.
        //
        TIntermAggregate* paramNodes = new TIntermAggregate;
        for (size_t i = 0; i < function->getParamCount(); i++) {
            const TParameter& param = function->getParam(i);
            if (param.name != 0) {
                TVariable *variable = new TVariable(param.name, *param.type);
                //
                // Insert the parameters with name in the symbol table.
                //
                if (! context->symbolTable.declare(*variable)) {
                    context->error(@1, "redefinition", variable->getName().c_str());
                    context->recover();
                    delete variable;
                }

                //
                // Add the parameter to the HIL
                //
                paramNodes = context->intermediate.growAggregate(
                                               paramNodes,
                                               context->intermediate.addSymbol(variable->getUniqueId(),
                                                                       variable->getName(),
                                                                       variable->getType(), @1),
                                               @1);
            } else {
                paramNodes = context->intermediate.growAggregate(paramNodes, context->intermediate.addSymbol(0, "", *param.type, @1), @1);
            }
        }
        context->intermediate.setAggregateOperator(paramNodes, EOpParameters, @1);
        $1.intermAggregate = paramNodes;
        context->loopNestingLevel = 0;
    }
    compound_statement_no_new_scope {
        //?? Check that all paths return a value if return type != void ?
        //   May be best done as post process phase on intermediate code
        if (context->currentFunctionType->getBasicType() != EbtVoid && ! context->functionReturnsValue) {
            context->error(@1, "function does not return a value:", "", $1.function->getName().c_str());
            context->recover();
        }
        
        $$ = context->intermediate.growAggregate($1.intermAggregate, $3, 0);
        context->intermediate.setAggregateOperator($$, EOpFunction, @1);
        $$->getAsAggregate()->setName($1.function->getMangledName().c_str());
        $$->getAsAggregate()->setType($1.function->getReturnType());

        // store the pragma information for debug and optimize and other vendor specific
        // information. This information can be queried from the parse tree
        $$->getAsAggregate()->setOptimize(context->pragma().optimize);
        $$->getAsAggregate()->setDebug(context->pragma().debug);

        if ($3 && $3->getAsAggregate())
            $$->getAsAggregate()->setEndLine($3->getAsAggregate()->getEndLine());

        context->symbolTable.pop();
    }
    ;

%%

int glslang_parse(TParseContext* context) {
    return yyparse(context);
}
